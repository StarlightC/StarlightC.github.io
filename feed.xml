<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://blog.sofself.com/</id><title>StarlightC</title><subtitle>StarlightC的Blog</subtitle> <updated>2022-04-24T13:40:42+08:00</updated> <author> <name>StarlightC</name> <uri>https://blog.sofself.com/</uri> </author><link rel="self" type="application/atom+xml" href="https://blog.sofself.com/feed.xml"/><link rel="alternate" type="text/html" hreflang="zh-CN" href="https://blog.sofself.com/"/> <generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator> <rights> © 2022 StarlightC </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>Kotlin学习与使用笔记</title><link href="https://blog.sofself.com/posts/Kotlin%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/" rel="alternate" type="text/html" title="Kotlin学习与使用笔记" /><published>2021-07-16T09:35:00+08:00</published> <updated>2021-07-16T09:35:00+08:00</updated> <id>https://blog.sofself.com/posts/Kotlin%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</id> <content src="https://blog.sofself.com/posts/Kotlin%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/" /> <author> <name>StarlightC</name> </author> <category term="Kotlin" /> <summary> 取消自动生成getter()和setter() 通常，Kotlin会自动为类中未定义getter()setter()的属性自动生成默认的getter()和setter(): class Foo{ var abc : String? = null } Kotlin 编译器会自动将属性补全为以下形式： private String abc; public final String getAbc(){...} public final void setAbc(String abc){...} 如果属性不需要getter()或setter(), 或者需要禁用生成的getter()或setter()以便构造Java模式的Builder，我们可以使用注解@JvmFile </summary> </entry> <entry><title>重构简述</title><link href="https://blog.sofself.com/posts/%E9%87%8D%E6%9E%84%E7%AE%80%E8%BF%B0/" rel="alternate" type="text/html" title="重构简述" /><published>2021-07-12T14:25:00+08:00</published> <updated>2021-07-12T14:25:00+08:00</updated> <id>https://blog.sofself.com/posts/%E9%87%8D%E6%9E%84%E7%AE%80%E8%BF%B0/</id> <content src="https://blog.sofself.com/posts/%E9%87%8D%E6%9E%84%E7%AE%80%E8%BF%B0/" /> <author> <name>StarlightC</name> </author> <category term="设计模式" /> <summary> 重构定义 如果你发现自己需要为程序添加一个特性 而代码结构使你无法很方便地达成目的 那就先重构那个程序 使特性的添加比较容易进行 然后再添加特性 重构之前 首先检查自己是否有一套可靠的测试机制 这些测试必须有自我检验能力 重构技术就是以微小的步伐修改程序 如果你犯下错误 很容易便可发现它 任何一个傻瓜都能写出计算机可以理解的代码 唯有写出人类容易理解的代码 才是优秀的程序员 重构(名词) 对软件内部结构的一种调整 目的是在不改变软件可观察行为的前提下 提供其可理解性 降低其修改成本 重构(动词) 使用一系列重构手法 在不改变软件可观察行为的前提下 调整其结构 重构目的 重构的目的是使软件更容易被理解和修改 与之形成对比的是性能优化 和重构一样 性能优化通常不会改变组件的行为(除了执行速度) 只会改变其内部结构 但是两者出发点不同 性能优化往往使代码较难理解 但为了得到... </summary> </entry> <entry><title>Android Studio插件开发记录</title><link href="https://blog.sofself.com/posts/Android-Studio%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/" rel="alternate" type="text/html" title="Android Studio插件开发记录" /><published>2021-06-18T14:50:00+08:00</published> <updated>2021-06-18T14:50:00+08:00</updated> <id>https://blog.sofself.com/posts/Android-Studio%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/</id> <content src="https://blog.sofself.com/posts/Android-Studio%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/" /> <author> <name>StarlightC</name> </author> <category term="Android Studio" /> <summary> 基于 IntelliJ IDEA CE (Build版本：202.7660.3 ，对应Android Studio 4.2.1） 相关资源 官方社区文档 Github仓库 创建Intellij IDEA插件简介 创建Intellij IDEA插件的高级指南 </summary> </entry> <entry><title>Binder原理</title><link href="https://blog.sofself.com/posts/Binder%E5%8E%9F%E7%90%86/" rel="alternate" type="text/html" title="Binder原理" /><published>2021-01-05T14:00:00+08:00</published> <updated>2021-01-05T14:00:00+08:00</updated> <id>https://blog.sofself.com/posts/Binder%E5%8E%9F%E7%90%86/</id> <content src="https://blog.sofself.com/posts/Binder%E5%8E%9F%E7%90%86/" /> <author> <name>StarlightC</name> </author> <category term="Android" /> <summary> Binder定义 机制、模型角度: Binder是一种Android中实现跨进程通讯（IPC）的方式，即Binder模型 结构、组成角度: Binder是一种虚拟的物理设备驱动，即Binder驱动 Android实现角度: Binder是一个类，实现了IBinder接口，即Binder类 Binder 跨进程通信机制、模型 Binder 跨进程通信机制模型基于CS模式 ServiceManager进程： 管理Service注册与查询，将字符形式的Binder名字转化成Client中对该Binder的应用 Binder驱动: 通过内存映射传递进程间的数据 实现线程控制：采用Binder的线程池，并由Binder驱动自身进行控制管理 具体步骤： Android中Binder Binder请求的线程管理 Server进程会创建很多线程... </summary> </entry> <entry><title>适配器模式</title><link href="https://blog.sofself.com/posts/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/" rel="alternate" type="text/html" title="适配器模式" /><published>2020-11-22T22:33:00+08:00</published> <updated>2020-11-22T22:33:00+08:00</updated> <id>https://blog.sofself.com/posts/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</id> <content src="https://blog.sofself.com/posts/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/" /> <author> <name>StarlightC</name> </author> <category term="设计模式" /> <summary> 定义 将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。 特点 优点 客户端通过适配器可以透明地调用目标接口。 复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。 将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。 在很多业务场景中符合开闭原则。 缺点 适配器编写过程需要结合业务场景全面考虑，可能会增加系统的复杂性。 增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱。 基本结构 适配器模式（Adapter）包含以下主要角色： 目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类... </summary> </entry> </feed>
