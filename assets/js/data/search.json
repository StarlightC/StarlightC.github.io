[ { "title": "Kotlin学习与使用笔记", "url": "/posts/Kotlin%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/", "categories": "Kotlin", "tags": "Kotlin, JVM, Android", "date": "2021-07-16 09:35:00 +0800", "snippet": "取消自动生成getter()和setter()通常，Kotlin会自动为类中未定义getter()setter()的属性自动生成默认的getter()和setter():class Foo{ var abc : String? = null}Kotlin 编译器会自动将属性补全为以下形式： private String abc; public final String getAbc(){...} public final void setAbc(String abc){...}如果属性不需要getter()或setter(), 或者需要禁用生成的getter()或setter()以便构造Java模式的Builder，我们可以使用注解@JvmFile" }, { "title": "重构简述", "url": "/posts/%E9%87%8D%E6%9E%84%E7%AE%80%E8%BF%B0/", "categories": "设计模式", "tags": "Refactoring", "date": "2021-07-12 14:25:00 +0800", "snippet": "重构定义如果你发现自己需要为程序添加一个特性 而代码结构使你无法很方便地达成目的 那就先重构那个程序 使特性的添加比较容易进行 然后再添加特性重构之前 首先检查自己是否有一套可靠的测试机制 这些测试必须有自我检验能力重构技术就是以微小的步伐修改程序 如果你犯下错误 很容易便可发现它任何一个傻瓜都能写出计算机可以理解的代码 唯有写出人类容易理解的代码 才是优秀的程序员重构(名词) 对软件内部结构的一种调整 目的是在不改变软件可观察行为的前提下 提供其可理解性 降低其修改成本重构(动词) 使用一系列重构手法 在不改变软件可观察行为的前提下 调整其结构重构目的重构的目的是使软件更容易被理解和修改与之形成对比的是性能优化 和重构一样 性能优化通常不会改变组件的行为(除了执行速度) 只会改变其内部结构 但是两者出发点不同 性能优化往往使代码较难理解 但为了得到所需的性能你不得不那么做重构不会改变软件可观察的行为 重构之后软件功能一如以往为何重构重构改进软件设计重构使软件更容易理解重构帮助找到bug重构提高编程速度何时重构三次法则 事不过三 三则重构添加功能时重构修补错误时重构复审代码时重构代码的坏味道 有以下情况进行重构Duplicated Code （重复代码）重复代码就是不同地点，有着相同的程序结构。一般是因为需求迭代比较快，开发小伙伴担心影响已有功能，就复制粘贴造成的。重复代码很难维护的，如果你要修改其中一段的代码逻辑，就需要修改多次，很可能出现遗漏的情况。如何优化重复代码呢？分三种情况讨论：同一个类的两个函数含有相同的表达式class A { public void method1() { doSomething1 doSomething2 doSomething3 } public void method2() { doSomething1 doSomething2 doSomething4 }}处理：可以使用 Extract Method(提取公共函数) 抽出重复的代码逻辑，组成一个公用的方法。class A { public void method1() { commonMethod(); doSomething3 } public void method2() { commonMethod(); doSomething4 } public void commonMethod(){ doSomething1 doSomething2 }}两个互为兄弟的子类内含相同的表达式class A extend C { public void method1() { doSomething1 doSomething2 doSomething3 }}class B extend C { public void method1() { doSomething1 doSomething2 doSomething4 }}处理：对两个类都使用 Extract Method(提取公共函数) ，然后把抽取出来的函数放到父类中。如果代码之间只是相似，而非完全相同，那么就得利用Extract Method将相似部分和差异部分分割开来，构成单独一个函数。然后使用 Form Template Method（塑造模版函数）构建一个 Template Method设计模式。class C { public void commonMethod(){ doSomething1 doSomething2 }}class A extend C { public void method1() { commonMethod(); doSomething3 }}class B extend C { public void method1() { commonMethod(); doSomething4 }}两个毫不相关的类出现重复代码如果是两个毫不相关的类出现重复代码，可以使用 Extract Class 将重复代码提炼到一个类中。这个新类可以是一个普通类，也可以是一个工具类，看具体业务怎么划分吧。Long Method (过长函数)过长函数是指一个函数方法几百行甚至上千行，可读性大大降低，不便于理解。范例如下：public class Test { private String name; private Vector&amp;lt;Order&amp;gt; orders = new Vector&amp;lt;Order&amp;gt;(); public void printOwing() { //print banner System.out.println(&quot;****************&quot;); System.out.println(&quot;*****customer Owes *****&quot;); System.out.println(&quot;****************&quot;); //calculate totalAmount Enumeration env = orders.elements(); double totalAmount = 0.0; while (env.hasMoreElements()) { Order order = (Order) env.nextElement(); totalAmount += order.getAmout(); } //print details System.out.println(&quot;name:&quot; + name); System.out.println(&quot;amount:&quot; + totalAmount); ...... }}可以使用 Extract Method ，抽取功能单一的代码段，组成命名清晰的小函数，去解决长函数问题，修改后如下:public class Test { private String name; private Vector&amp;lt;Order&amp;gt; orders = new Vector&amp;lt;Order&amp;gt;(); public void printOwing() { //print banner printBanner(); //calculate totalAmount double totalAmount = getTotalAmount(); //print details printDetail(totalAmount); } void printBanner(){ System.out.println(&quot;****************&quot;); System.out.println(&quot;*****customer Owes *****&quot;); System.out.println(&quot;****************&quot;); } double getTotalAmount(){ Enumeration env = orders.elements(); double totalAmount = 0.0; while (env.hasMoreElements()) { Order order = (Order) env.nextElement(); totalAmount += order.getAmout(); } return totalAmount; } void printDetail(double totalAmount){ System.out.println(&quot;name:&quot; + name); System.out.println(&quot;amount:&quot; + totalAmount); } }如果函数内部有大量的参数和临时变量，它们会对函数提炼形成阻碍。这时不能采用 Extract Method ，该方式会使许多参数和临时变量成为抽取出来对方法的参数，导致代码的可读性几乎没有任何提升。这个时候我们可以采用 Replace Temp with Query(以查询代替临时变量) 来消除这些临时元素。 Introduce Parameter Object(引入参数对象) 和 Preserve Whole Object(保持完整对象) 来将过长的参数列表变得简洁些。Hint:函数中层次过多的条件表达式和循环常常也是需要提炼的信号。对于条件表达式，我们可以采用 Decompose Conditional(分解条件表达式)。对于循环，则考虑将循环和其内的代码提炼到一个独立函数中。Large Class (过大的类)一个类做太多事情，维护了太多功能，可读性变差，性能也会下降。举个例子，订单相关的功能你放到一个类A里面，商品库存相关的也放在类A里面，积分相关的还放在类A里面…范例如下：Class A{ public void printOrder(){ System.out.println(&quot;订单&quot;); } public void printGoods(){ System.out.println(&quot;商品&quot;); } public void printPoints(){ System.out.println(&quot;积分&quot;); }}此时各种代码混杂于一个类中，致使该类的可读性较差。通常，我们根据单一职责原则，使用 Extract Class 把代码划分开，修改后如下：Class Order{ public void printOrder(){ System.out.println(&quot;订单&quot;); }}Class Goods{ public void printGoods(){ System.out.println(&quot;商品&quot;); }} Class Points{ public void printPoints(){ System.out.println(&quot;积分&quot;); } }}如果类中的实例变量或方法只有部分地方使用， 我们可以考虑使用 Extract Subclass(提取子类) 。同时，上述两个方法也可以多次使用。如果该 Large Class 是一个关于GUI的类，我们可能需要把数据和行为移动到一个独立的领域对象中。这时可能需要两边各保留一些重复数据，并保持两边同步。可以考虑采用 Duplicate Obeserved Data(复制被观察的数据) 方式实现。Long Parameter List (过长参数列)方法参数数量过多的话，可读性很差。如果有多个重载方法，参数很多的话，有时候你都不知道调哪个呢。并且，如果参数很多，做新老接口兼容处理也比较麻烦。public void getUserInfo（String name,String age,String sex,String mobile){ // do something ...}如何解决过长参数列问题呢？将参数封装成结构或者类，比如我们将参数封装成一个DTO类，如下：public void getUserInfo（UserInfoParamDTO userInfoParamDTO){ // do something ...}class UserInfoParamDTO{ private String name; private String age; private String sex; private String mobile;}这里有个重要的例外： 优势我们明显不希望造成“被调用对象”与将“较大对象”间的某种依赖关系。这时候将数据从对象中拆解出来单独作为参数，也很合情理。但是请注意其所引发的代价。如果参数列太长或变化太频繁，就需要重新考虑自己的依赖结构了。Divergent Change （发散式变化）对程序进行维护时, 如果添加修改组件, 要同时修改一个类中的多个方法, 那么这就是 Divergent Change。举个汽车的例子，某个汽车厂商生产三种品牌的汽车：BMW、Benz和LaoSiLaiSi，每种品牌又可以选择燃油、纯电和混合动力。范例如下：public class Car { private String name; void start(Engine engine) { if (&quot;HybridEngine&quot;.equals(engine.getName())) { System.out.println(&quot;Start Hybrid Engine...&quot;); } else if (&quot;GasolineEngine&quot;.equals(engine.getName())) { System.out.println(&quot;Start Gasoline Engine...&quot;); } else if (&quot;ElectricEngine&quot;.equals(engine.getName())) { System.out.println(&quot;Start Electric Engine&quot;); } } void drive(Engine engine,Car car) { this.start(engine); System.out.println(&quot;Drive &quot; + getBrand(car) + &quot; car...&quot;); } String getBrand(Car car) { if (&quot;Baoma&quot;.equals(car.getName())) { return &quot;BMW&quot;; } else if (&quot;BenChi&quot;.equals(car.getName())) { return &quot;Benz&quot;; } else if (&quot;LaoSiLaiSi&quot;.equals(car.getName())) { return &quot;LaoSiLaiSi&quot;; } return null; }}如果新增一种品牌新能源电车，然后它的启动引擎是核动力，那么就需要修改Car类的start和getBrand方法，这就是代码坏味道：Divergent Change （发散式变化）。如何优化呢？一句话总结：拆分类，将总是一起变化的东西放到一块。★运用提炼类(Extract Class) 拆分类的行为。如果不同的类有相同的行为，提炼超类(Extract Superclass) 和 提炼子类(Extract Subclass)。”修改后如下：因为Engine是独立变化的，所以提取一个Engine接口，如果新加一个启动引擎，多一个实现类即可。如下：//IEnginepublic interface IEngine { void start();}public class HybridEngineImpl implements IEngine { @Override public void start() { System.out.println(&quot;Start Hybrid Engine...&quot;); }}因为drive方法依赖于Car，IEngine，getBand方法;getBand方法是变化的，也跟Car是有关联的，所以可以搞个抽象Car的类，每个品牌汽车继承于它即可，如下public abstract class AbstractCar { protected IEngine engine; public AbstractCar(IEngine engine) { this.engine = engine; } public abstract void drive();}//奔驰汽车public class BenzCar extends AbstractCar { public BenzCar(IEngine engine) { super(engine); } @Override public void drive() { this.engine.start(); System.out.println(&quot;Drive &quot; + getBrand() + &quot; car...&quot;); } private String getBrand() { return &quot;Benz&quot;; }}//宝马汽车public class BaoMaCar extends AbstractCar { public BaoMaCar(IEngine engine) { super(engine); } @Override public void drive() { this.engine.start(); System.out.println(&quot;Drive &quot; + getBrand() + &quot; car...&quot;); } private String getBrand() { return &quot;BMW&quot;; }}可以发现不同子类BaoMaCar和BenzCar的drive方法，还是有相同代码，所以我们可以再扩展一个抽象子类，把drive方法推进去，如下:public abstract class AbstractRefinedCar extends AbstractCar { public AbstractRefinedCar(IEngine engine) { super(engine); } @Override public void drive() { this.engine.start(); System.out.println(&quot;Drive &quot; + getBrand() + &quot; car...&quot;); } abstract String getBrand();}//宝马public class BaoMaRefinedCar extends AbstractRefinedCar { public BaoMaRefinedCar(IEngine engine) { super(engine); } @Override String getBrand() { return &quot;BMW&quot;; }}如果再添加一个新品牌，搞个子类，继承AbstractRefinedCar即可，如果新增一种启动引擎，也是搞个类实现IEngine接口即可Shotgun Surgery（霰弹式修改）当你实现某个小功能时，你需要在很多不同的类做出小修改。这就是Shotgun Surgery。它跟发散式变化(Divergent Change) 的区别就是，它指的是同时对多个类进行单一的修改，发散式变化指在一个类中修改多处。范例如下：public class DbAUtils { @Value(&quot;${db.mysql.url}&quot;) private String mysqlDbUrl; ...}public class DbBUtils { @Value(&quot;${db.mysql.url}&quot;) private String mysqlDbUrl; ...}多个类使用了db.mysql.url这个变量，如果将来需要切换mysql到别的数据库，如Oracle，那就需要修改多个类的这个变量！如何优化呢？将各个修改点，集中到一起，抽象成一个新类。★ 可以使用 Move Method （搬移函数）和 Move Field （搬移字段）把所有需要修改的代码放进同一个类，如果没有合适的类，就去new一个。”修改后如下：public class DbUtils { @Value(&quot;${db.mysql.url}&quot;) private String mysqlDbUrl; ...}Feature Envy (依恋情节)某个函数为了计算某个值，从另一个对象那里调用几乎半打的取值函数。通俗点讲，就是一个函数使用了大量其他类的成员，有人称之为红杏出墙的函数。范例如下：public class User{ private Phone phone; public User(Phone phone){ this.phone = phone; } public void getFullPhoneNumber(Phone phone){ System.out.println(&quot;areaCode:&quot; + phone.getAreaCode()); System.out.println(&quot;prefix：&quot; + phone.getPrefix()); System.out.println(&quot;number：&quot; + phone.getNumber()); }}如何解决呢？在这种情况下，你可以考虑将这个方法移动到它使用的那个类中。例如，要将 getFullPhoneNumber()从 User 类移动到Phone类中，因为它调用了Phone类的很多方法。但是有几个复杂精巧的设计模式破坏了这个规则，例如Strategy和Visitor，它们最根本的原则是：将总是一起变化的东西放在一起。数据和引用这些数据的行为总是一起变化的，如果出现例外，我们就搬移那些行为，保持变化只在一地发生。Strategy和Visitor使得我们能够轻松修改函数行为，因为它们将少量需被覆写的行为隔离开————当然这也付出了“多一层间接性”的代价。Data Clumps（数据泥团）数据项就像小孩子，喜欢成群结队地呆在一块。如果一些数据项总是一起出现的，并且一起出现更有意义的，就可以考虑，按数据的业务含义来封装成数据对象。范例如下：public class User { private String firstName; private String lastName; private String province; private String city; private String area; private String street;}修改后：public class User { private UserName username; private Adress adress;}class UserName{ private String firstName; private String lastName;}class Address{ private String province; private String city; private String area; private String street;}Primitive Obsession （基本类型偏执)多数编程环境都有两种数据类型，结构类型和基本类型。这里的基本类型，如果指Java语言的话，不仅仅包括那八大基本类型，也包括String等。如果是经常一起出现的基本类型，可以考虑把它们封装成对象。对于像电话前缀、邮政编码等特殊字符串，可以考虑使用 Replace Data Value with Object(将数据值替换为对象) 。对于类型码之类的也可以使用 Replace Type Code with Object 或 Replace Type Code with State/Strategy(以状态/策略取代类型码)范例如下：// 订单public class Order { private String customName; private String address; private Integer orderId; private Integer price;}修改后：// 订单类public class Order { private Custom custom; private Integer orderId; private Integer price;}// 把custom相关字段封装起来，在Order中引用Custom对象public class Custom { private String name; private String address;}这并不是指对所有的基本类型都建议封装成对象，只有关联或者一起出现的才考虑使用（类似Data Clamps的情形）。Switch Statements （Switch 语句）这里的Switch语句，不仅包括Switch相关的语句，也包括多层if…else的语句哈。很多时候，switch语句的问题就在于重复，如果你为它添加一个新的case语句，就必须找到所有的switch语句并且修改它们。示例代码如下： String medalType = &quot;guest&quot;; if (&quot;guest&quot;.equals(medalType)) { System.out.println(&quot;嘉宾勋章&quot;); } else if (&quot;vip&quot;.equals(medalType)) { System.out.println(&quot;会员勋章&quot;); } else if (&quot;guard&quot;.equals(medalType)) { System.out.println(&quot;守护勋章&quot;); } //...这种场景可以考虑使用多态优化：//勋章接口public interface IMedalService { void showMedal();}//守护勋章策略实现类public class GuardMedalServiceImpl implements IMedalService { @Override public void showMedal() { System.out.println(&quot;展示守护勋章&quot;); }}//嘉宾勋章策略实现类public class GuestMedalServiceImpl implements IMedalService { @Override public void showMedal() { System.out.println(&quot;嘉宾勋章&quot;); }}//勋章服务工厂类public class MedalServicesFactory { private static final Map&amp;lt;String, IMedalService&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); static { map.put(&quot;guard&quot;, new GuardMedalServiceImpl()); map.put(&quot;vip&quot;, new VipMedalServiceImpl()); map.put(&quot;guest&quot;, new GuestMedalServiceImpl()); } public static IMedalService getMedalService(String medalType) { return map.get(medalType); }}当然，多态只是优化的一个方案，一个方向。如果只是单一函数有些简单选择示例，并不建议动不动就使用动态，因为显得有点杀鸡使用牛刀了。Parallel Inheritance Hierarchies（ 平行继承体系）平行继承体系 其实算是Shotgun Surgery的特殊情况啦。当你为A类的一个子类Ax，也必须为另一个类B相应的增加一个子类Bx。消除这种重复性的一般策略是：让一个继承体系的实例应用另一个继承体系的实例。进一步，为了消除这种耦合我们可以使用 Move Method 和 Move Method 将使用引用的地方移至所引用的继承体系下，这样就可以将引用端的继承体系消弭于无形。Lazy Class (冗赘类)有的类经过项目的不断演化、需求的不断变更、或者经过一系列的重构之后，原本对得起自己身价的一个类，慢慢变得身形缩水，不再做这么多工作：或者开发者事前规划类某些变化，并添加一个类来应付这些变化，但实际上这些变化并没有发生。 如果某些子类没有做足够的工作，可以尝试对其使用 Collapse Hierarchy(折叠继承体系)。 对于几乎没用的组件则应该采用 Inline Class(将类内联化)Speculative Generality(夸夸其谈未来性)尽量避免过度设计的代码。例如：只有一个if else，那就不需要班门弄斧使用多态;如果某个抽象类没有什么太大的作用，就运用 Collapse Hierarchy(折叠继承体系) 如果某个函数名称带有多余的抽象意味，那么就对它进行重命名，让它现实一点。如果函数的某些参数没用上，就移除。Temporary Field(令人迷惑的临时字段)某个实例变量仅为某种特定情况而定而设，这样的代码就让人不易理解，我们称之为 Temporary Field(令人迷惑的临时字段)。 范例如下:public class PhoneAccount { private double excessMinutesCharge; private static final double RATE = 8.0; public double computeBill(int minutesUsed, int includedMinutes) { excessMinutesCharge = 0.0; int excessMinutes = minutesUsed - includedMinutes; if (excessMinutes &amp;gt;= 1) { excessMinutesCharge = excessMinutes * RATE; } return excessMinutesCharge; } public double chargeForExcessMinutes(int minutesUsed, int includedMinutes) { computeBill(minutesUsed, includedMinutes); return excessMinutesCharge; }}临时字段excessMinutesCharge在这里就比较多余，可以直接移除。有时一个类中有一个复杂算法，需要好几个变量。由于实现者不希望使用时传入一大串参数，所以将这些参数都放进字段中。但是这些参数只是在使用该算法的时候才有效，其他情况下只会使人陷入迷惑。我们可以将其和与其相关的函数提炼到一个新的类中，提炼后的新对象将是一个函数对象.Message Chains (过度耦合的消息链)当你看到用户向一个对象请求另一个对象，然后再向后者请求另一个对象，然后再请求另一个对象…这就是消息链。实际代码中，你看到的可能是一长串getThis（）或一长串临时变量。范例如下：A.getB().getC().getD().getTianLuoBoy().getData();A想要获取需要的数据时，必须要知道B，又必须知道C,又必须知道D…采取这种方式，意味着客户代码将与查找过程中的导航结构紧密耦合，一旦对象间的关系发生任何变化，客户端就不得不做出相应的修改。这时候应该使用 Hide Delegate(隐藏“委托关系”)Middle Man （中间人）对象的基本特征之一就是封装，即对外部世界隐藏其内部细节。封装往往伴随委托，但人们可能过度运用委托：某个类接口有一半的函数都委托给其他类。可以使用 Remove Middle Man 优化。直接和真正负责的对象打交道。如果这样的函数只有少数几个，可以使用 Inline Method 将它们放进调用端。如果这些中间人还有其他行为，可以使用 Replace Delegation with Inheritance(用继承替代委托) 解决，这样你既可以扩展原对象的行为，又不必负担那么多的委托请求。Inappropriate Intimacy（狎昵关系）如果两个类过于亲密，过分狎昵，你中有我，我中有你，两个类彼此使用对方的私有的东西，就是一种坏代码味道。我们称之为Inappropriate Intimacy（狎昵关系）建议尽量把有关联的方法或属性抽离出来，放到公共类，以减少关联。继承往往也会造成过度亲密，因为子类对超类的了解总是超过厚泽的主观愿望。如果出现过度亲密的情况，请考虑使用Replace Inheritance with Delegation(用委托替代继承)Alternative Classes with Different Interfaces （异曲同工的类）A类的接口a，和B类的接口b，做的的是相同一件事，或者类似的事情。我们就把A和B叫做异曲同工的类。首先可以尝试移除其中的方法然后重命名。但这往往不够，我们常常需要不断地移动方法将某些行为移入类，知道两者的协议一致为止。如果发现必须重复而累赘地移入代码才能完成这些，可以尝试提炼子类减少以一些工作。Incomplete Library Class (不完美的类库)大多数对象只要够用就好，如果类库构造得不够好，我们不可能修改其中的类使它完成我们希望完成的工作。可以使用 Introduce Foreign Method(引入外加函数) 或 Introduce Local Extension（引入本地扩展） ：外包一层函数 或 构建一个新的包装类/子类Data Class （纯数据类）什么是Data Class? 它们拥有一些字段，以及用于访问(读写)这些字段的函数。这些类很简单，仅有公共成员变量，或简单操作的函数。如何优化呢？将相关操作封装进去，减少public成员变量。比如：如果拥有public字段-&amp;gt; Encapsulate Field如果这些类内含容器类的字段，应该检查它们是不是得到了恰当地封装-&amp;gt; Encapsulate Collection封装起来对于不该被其他类修改的字段-&amp;gt; Remove Setting Method-&amp;gt;找出取值/设置函数被其他类运用的地点-&amp;gt; Move Method 把这些调用行为搬移到Data Class来。如果无法搬移整个函数，就运用Extract Method产生一个可被搬移的函数-&amp;gt;Hide Method把这些取值/设置函数隐藏起来。Refused Bequest （被拒绝的馈赠）子类应该继承父类的数据和函数。子类继承得到所有函数和数据，却只使用了几个，传统说法那就是继承体系设计错误，需要优化。需要为这个子类新建一个兄弟类-&amp;gt;Push Down Method和Push Down Field把所有用不到的函数下推给兄弟类，这样一来，超类就只持有所有子类共享的东西。所有超类都应该是抽象的。以上为传统说法中的观点，但是我们不建议这么做，我们常使用继承来方便的实现复用一些行为。如果子类复用了超类的实现，又不愿意支持超类的接口，可以不以为然。但是不能胡乱修改继承体系-&amp;gt;Replace Inheritance with Delegation(用委派替换继承).Comments (过多的注释)避免用注释解释代码，避免过多的注释。这些都是常见注释的坏味道：多余的解释日志式注释用注释解释变量等…如何优化呢？方法函数、变量的命名要规范、浅显易懂、避免用注释解释代码。关键、复杂的业务，使用清晰、简明的注释神奇命名方法函数、变量、类名、模块等，都需要简单明了，浅显易懂。避免靠自己主观意识瞎起名字。尽量使用全称，减少使用不易理解的缩写。范例：boolean test = checkParamResult(request);修改后：boolean isParamPass = checkParamResult(request);神奇魔法数日常开发中，可能会遇到这种代码：if(userType==1){ //doSth1}else If( userType ==2){ //doSth2}//...代码中的这个1和2都表示什么意思呢？再比如setStatus(1)中的1又表示什么意思呢？看到类似坏代码，可以这两种方式优化：改用继承，和之前的switch重构采用一样的策略使用枚举类，把相关的数字按照功能或业务划分命名后统一管理。参考与感谢:软工实验：常见的代码坏味道以及重构举例22种代码的坏味道，一句话概括重构】 代码的坏味道总结 Bad SmellCode Smell《重构改善既有代码的设计》25种代码坏味道总结+优化示例" }, { "title": "Android Studio插件开发记录", "url": "/posts/Android-Studio%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/", "categories": "Android Studio", "tags": "Intellij Idea, Android Studio, 插件", "date": "2021-06-18 14:50:00 +0800", "snippet": "基于 IntelliJ IDEA CE (Build版本：202.7660.3 ，对应Android Studio 4.2.1）相关资源 官方社区文档 Github仓库 创建Intellij IDEA插件简介 创建Intellij IDEA插件的高级指南" }, { "title": "Binder原理", "url": "/posts/Binder%E5%8E%9F%E7%90%86/", "categories": "Android", "tags": "Android", "date": "2021-01-05 14:00:00 +0800", "snippet": "Binder定义 机制、模型角度: Binder是一种Android中实现跨进程通讯（IPC）的方式，即Binder模型 结构、组成角度: Binder是一种虚拟的物理设备驱动，即Binder驱动 Android实现角度: Binder是一个类，实现了IBinder接口，即Binder类Binder 跨进程通信机制、模型Binder 跨进程通信机制模型基于CS模式ServiceManager进程：管理Service注册与查询，将字符形式的Binder名字转化成Client中对该Binder的应用Binder驱动: 通过内存映射传递进程间的数据 实现线程控制：采用Binder的线程池，并由Binder驱动自身进行控制管理具体步骤：Android中BinderBinder请求的线程管理Server进程会创建很多线程来处理Binder请求Binder模型的线程管理 采用Binder驱动的线程池，并由Binder驱动自身进行管理，而不是由Server进程来管理的。一个进程的Binder线程数默认最大是16，超过的请求会被阻塞等待空闲的Binder线程。所以，在进程间通信时处理并发问题时，如使用ContentProvider时，它的CRUD（创建、检索、更新和删除）方法只能同时有16个线程同时工作Android中的具体实现Binder机制在 Android中的实现主要依靠 Binder类，其实现了 IBinder 接口注册服务Server进程 通过Binder驱动 向 Service Manager进程 注册服务Binder binder = new Stub(); IInterface plus = new IPlus(){ // 确定Client进程需要调用的方法 public int add(int a,int b) { return a+b; } // 实现IInterface接口中唯一的方法 public IBinder asBinder（）{ return null ; }}; // 步骤3 binder.attachInterface(plus，&quot;add two int&quot;); public class Stub extends Binder { // 复写onTransact（） @Override boolean onTransact(int code, Parcel data, Parcel reply, int flags){ switch (code) { case Stub.add： { data.enforceInterface(&quot;add two int&quot;); int arg0 = data.readInt(); int arg1 = data.readInt(); int result = this.queryLocalIInterface(&quot;add two int&quot;) .add( arg0, arg1); reply.writeInt(result); return true; } } return super.onTransact(code, data, reply, flags); } public class Binder implement IBinder{ // Binder机制在Android中的实现主要依靠的是Binder类，其实现了IBinder接口 // IBinder接口：定义了远程操作对象的基本接口，代表了一种跨进程传输的能力 // 系统会为每个实现了IBinder接口的对象提供跨进程传输能力 // 即Binder类对象具备了跨进程传输的能力 void attachInterface(IInterface plus, String descriptor)； // 作用： // 1. 将（descriptor，plus）作为（key,value）对存入到Binder对象中的一个Map&amp;lt;String,IInterface&amp;gt;对象中 // 2. 之后，Binder对象 可根据descriptor通过queryLocalIInterface（）获得对应IInterface对象（即plus）的引用，可依靠该引用完成对请求方法的调用 IInterface queryLocalInterface(Stringdescriptor) ； // 作用：根据 参数 descriptor 查找相应的IInterface对象（即plus引用） boolean onTransact(int code, Parcel data, Parcel reply, int flags)； // 定义：继承自IBinder接口的 // 作用：执行Client进程所请求的目标方法（子类需要复写） // 参数说明： // code：Client进程请求方法标识符。即Server进程根据该标识确定所请求的目标方法 // data：目标方法的参数。（Client进程传进来的，此处就是整数a和b） // reply：目标方法执行后的结果（返回给Client进程） // 注：运行在Server进程的Binder线程池中；当Client进程发起远程请求时，远程请求会要求系统底层执行回调该方法 final class BinderProxy implements IBinder { // 即Server进程创建的Binder对象的代理对象类 // 该类属于Binder的内部类 }} public interface IPlus extends IInterface { // 定义需要实现的接口方法，即Client进程需要调用的方法 public int add(int a,int b);// 返回步骤2}// 进程间通信定义的通用接口// 通过定义接口，然后再服务端实现接口、客户端调用接口，就可实现跨进程通信。public interface IInterface{ // 只有一个方法：返回当前接口关联的 Binder 对象。 public IBinder asBinder();} // 回到分析3原处获取服务使用服务Client进程 根据获取到的 Service信息（Binder代理对象），通过Binder驱动 建立与 该Service所在Server进程通信的链路，并开始使用服务Client进程 将参数（整数a和b）发送到Server进程// 1. Client进程 将需要传送的数据写入到Parcel对象中// data = 数据 = 目标方法的参数（Client进程传进来的，此处就是整数a和b） + IInterface接口对象的标识符descriptor android.os.Parcel data = android.os.Parcel.obtain(); data.writeInt(a); data.writeInt(b); data.writeInterfaceToken(&quot;add two int&quot;);； // 方法对象标识符让Server进程在Binder对象中根据&quot;add two int&quot;通过queryLocalIInterface（）查找相应的IInterface对象（即Server创建的plus），Client进程需要调用的相加方法就在该对象中 android.os.Parcel reply = android.os.Parcel.obtain(); // reply：目标方法执行后的结果（此处是相加后的结果）// 2. 通过 调用代理对象的transact（） 将 上述数据发送到Binder驱动 binderproxy.transact(Stub.add, data, reply, 0) // 参数说明： // 1. Stub.add：目标方法的标识符（Client进程 和 Server进程 自身约定，可为任意） // 2. data ：上述的Parcel对象 // 3. reply：返回结果 // 0：可不管// 注：在发送数据后，Client进程的该线程会暂时被挂起// 所以，若Server进程执行的耗时操作，请不要使用主线程，以防止ANR// 3. Binder驱动根据 代理对象 找到对应的真身Binder对象所在的Server 进程（系统自动执行）// 4. Binder驱动把 数据 发送到Server 进程中，并通知Server 进程执行解包（系统自动执行）Server进程根据Client进要求 调用 目标方法（即加法函数）/ 1. 收到Binder驱动通知后，Server 进程通过回调Binder对象onTransact（）进行数据解包 &amp;amp; 调用目标方法 public class Stub extends Binder { // 复写onTransact（） @Override boolean onTransact(int code, Parcel data, Parcel reply, int flags){ // code即在transact（）中约定的目标方法的标识符 switch (code) { case Stub.add： { // a. 解包Parcel中的数据 data.enforceInterface(&quot;add two int&quot;); // a1. 解析目标方法对象的标识符 int arg0 = data.readInt(); int arg1 = data.readInt(); // a2. 获得目标方法的参数 // b. 根据&quot;add two int&quot;通过queryLocalIInterface（）获取相应的IInterface对象（即Server创建的plus）的引用，通过该对象引用调用方法 int result = this.queryLocalIInterface(&quot;add two int&quot;) .add( arg0, arg1); // c. 将计算结果写入到reply reply.writeInt(result); return true; } } return super.onTransact(code, data, reply, flags); // 2. 将结算结果返回 到Binder驱动Server进程 将目标方法的结果（即加法后的结果）返回给Client进程/ 1. Binder驱动根据 代理对象 沿原路 将结果返回 并通知Client进程获取返回结果 // 2. 通过代理对象 接收结果（之前被挂起的线程被唤醒） binderproxy.transact(Stub.ADD, data, reply, 0)； reply.readException();； result = reply.readInt()； }}优点相关进程空间划分一个进程空间分为：用户空间 和 内核空间进程间    用户空间的数据不可共享    内核空间的数据可共享所有进程共用1个内核空间内核空间与用户空间 通过系统调用（SystemCall）进行交互copy_from_user(); //将用户空间的数据拷贝到内核空间copy_to_user(); //将内核空间的数据拷贝到用户空间由于进程隔离，一般的跨进程通信需要如下流程 通过copy_from_user()，将需发送的数据拷贝到内核空间 内核服务程序 唤醒需接受数据的接受线程 通过copy_to_user()将数据发送到接受进程的用户空间内存映射" }, { "title": "适配器模式", "url": "/posts/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/", "categories": "设计模式", "tags": "Adapter Pattern", "date": "2020-11-22 22:33:00 +0800", "snippet": "定义将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。特点优点 客户端通过适配器可以透明地调用目标接口。 复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。 将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。 在很多业务场景中符合开闭原则。缺点 适配器编写过程需要结合业务场景全面考虑，可能会增加系统的复杂性。 增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱。基本结构适配器模式（Adapter）包含以下主要角色： 目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。 适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。 适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。类适配器模式：对象适配器模式：实例类适配器模式package adapter;//目标接口interface Target{ public void request();}//适配者接口class Adaptee{ public void specificRequest() { System.out.println(&quot;适配者中的业务代码被调用！&quot;); }}//类适配器类class ClassAdapter extends Adaptee implements Target{ public void request() { specificRequest(); }}//客户端代码public class ClassAdapterTest{ public static void main(String[] args) { System.out.println(&quot;类适配器模式测试：&quot;); Target target = new ClassAdapter(); target.request(); }}对象适配器package adapter;//对象适配器类class ObjectAdapter implements Target{ private Adaptee adaptee; public ObjectAdapter(Adaptee adaptee) { this.adaptee=adaptee; } public void request() { adaptee.specificRequest(); }}//客户端代码public class ObjectAdapterTest{ public static void main(String[] args) { System.out.println(&quot;对象适配器模式测试：&quot;); Adaptee adaptee = new Adaptee(); Target target = new ObjectAdapter(adaptee); target.request(); }}" }, { "title": "Java中的synchronized修饰符", "url": "/posts/Java%E4%B8%AD%E7%9A%84synchronized%E4%BF%AE%E9%A5%B0%E7%AC%A6/", "categories": "Java", "tags": "Java基础", "date": "2020-10-23 23:46:00 +0800", "snippet": "基础Synchronized的作用主要有三个： 确保线程互斥的访问同步代码 保证共享变量的修改能够及时可见 有效解决重排序问题用法修饰普通方法锁的是实例对象，进入同步方法前要获得实例对象的锁。同步范围为synchronized修饰的方法，其他线程可以同时访问该实例对象的非synchronized修饰方法public class Test{ public synchronized void method_f(){ //do some thing; } public synchronized void method_s(){ //do some thing; } public synchronized void method_t(){ //do some thing; } public static void main(String[] args){ final Test stest = new Test(); new Thread(new Runnable(){ @Override public void run(){ stest.method_f(); } }).start(); new Thread(new Runnable(){ @Override public void run(){ stest.method_s(); } }).start(); }}程序将先由线程1执行完method_f()，之后线程2在执行method_s()如果修改main函数为：public static void main(String[] args){ final Test stest = new Test(); final Test mtest = new Test(); new Thread(new Runnable(){ @Override public void run(){ stest.method_f(); } }).start(); new Thread(new Runnable(){ @Override public void run(){ mtest.method_s(); } }).start(); }}两个线程将会同时执行各自的方法修饰静态方法锁是class对象锁，进入同步方法前，需要获取当前类的class对象锁。静态成员不属于任何对象，是类成员，因此通过class对象锁可以控制静态 成员的并发操作。注： 如果一个线程A调用一个实例对象的非static synchronized方法，而线程B需要调用这个实例对象所属类的静态 synchronized方法，是允许的，不会发生互斥现象。因为访问静态 synchronized 方法占用的锁是当前类的class对象，而访问非静态 synchronized 方法占用的锁是当前实例对象锁.修饰代码块锁是括号里的对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。在某些情况下，我们编写的方法体可能比较大，同时存在一些比较耗时的操作，而需要同步的代码又只有一小部分，如果直接对整个方法进行同步操作，可能会得不偿失，此时我们可以使用同步代码块的方式对需要同步的代码进行包裹，这样就无需对整个方法进行同步操作了。 public class synchronizedTest implements Runnable { static synchronizedTest instance=new synchronizedTest(); static int i=0; @Override public void run() { //省略其他耗时操作.... //使用同步代码块对变量i进行同步操作,锁对象为instance synchronized(instance){ for(int j=0;j&amp;lt;10000;j++){ i++; } } } public static void main(String[] args) throws InterruptedException { Thread t1=new Thread(instance); Thread t2=new Thread(instance); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(i); }}" }, { "title": "欧几里得算法", "url": "/posts/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/", "categories": "算法", "tags": "最大公约数", "date": "2020-10-22 17:11:00 +0800", "snippet": "欧几里得算法（辗转相除法）设gcd(a,b)是计算自然数a和b的最大公约数的函数，a除b得到的商和余数分别为p和q，因为a=b×p+q，所以gcd(b,q)既整除a又整除b，也就是整除gcd(a,b)。反之，因为q=a-b×p，同理可证gcd(a,b)整除gcd(b,q)。因此可以知道gcd(a,b)=gcd(b,a%b)。不断这样操作下去，由于gcd的第二个参数总是不断减小的，最终会得到gcd(a,b)=gcd(c,0)。0和c的最大公约数是c，这样便计算出了a，b的最大公约数为c。int gcd(int a, int b){ if(b == 0) return a; return gcd(b, a%b);}时间复杂度O(log max(a,b))之内扩展欧几里得算法贝祖定理： 对于给定的正整数a，b，方程ax+by=c有解的充要条件为c是gcd（a，b）的整数倍根据欧几里得算法，当到达递归边界的时候，a_i== gcd(a_0,b_0) , b_i == 0，可以得到一个较为明显的解： a_i * 1 + b_i * 0 = gcd(a_0,b_0) ,即 x_i = 1, y_i = 0。因为递归的特性是由最终状态逐层返回的，现在我们已经知道了最终状态的x_i 和y_i，只需要找出x和y变化的关系式即可。由欧几里得算法可得：a * x_0 + b * y_0 = gcd(a ,b )b * x_1 + (a % b) * y_1 = gcd(a,b)因为a % b = a - ( a / b) * b（此处”/”为整除）b * x_1 + a * y_1 - ( a / b) * b * y_1 = gcd(a,b)a * y_1 + b * ( x_1 - ( a / b) * y_1) = gcd(a,b)即：x_0 = y_1 , y_0 = (x_1 - a / b) * y_1)代码实现：int exgcd(int a,int b,int &amp;amp;x,int &amp;amp;y)//扩展欧几里得算法{ if(b==0) { x=1;y=0; return a; //到达递归边界开始向上一层返回 } int r=exgcd(b,a%b,x,y); int temp=y; //把x y变成上一层的 y=x-(a/b)*y; x=temp; return r; //得到a b的最大公因数" }, { "title": "素数检测", "url": "/posts/%E7%B4%A0%E6%95%B0%E6%A3%80%E6%B5%8B/", "categories": "算法", "tags": "素数", "date": "2020-10-22 17:03:00 +0800", "snippet": " 素数是指恰好有两个约数的整数（1和其本身）。简单素性测试因为n的约数都不超过n，所以只需检查2~n-1的所偶整数是否整除n就能判定n是否为素数。进而，如果d是n的约数，那么n/d也是n的约数。由n=d×n/d可知min(d,n/d)≤sqrt(n)，所以只要检查 2~sqrt(n) 得到所有整数就可以了。由此可知，整数分解和约数枚举都可以在 O(sqrt(n)) 时间内完成。埃氏筛法要枚举n以内的素数，可以用埃氏筛法。 首先，将2到n范围内的所有整数写下来。 其中最小的数字2是素数。将表中所有2的倍数都划去， 表中剩余的最小数字是3，他不能被更小的数长出，所以是素数。在将表中所有3的倍数都划去。 以此类推，如果表中剩余的最小数字是m时，m就是素数。然后将表中所有m的倍数划去。像这样反复操作，就能一次枚举n以内的素数。 int prime[MAX_N];//第i个素数bool is_prime[MAX_N+1]//is_prime[i]为true表示i时素数//返回n以内素数的个数int sieve(int n){ int p = 0; for(int i = 0; i &amp;lt;= n; i++) is_prime[i] = true; is_prime[0] = false; is_prime[1] = false; for(int i = 2; i &amp;lt;= n; i++){ if(is_prime[i]){ prime[p++] = i; for(int j = 2 * i; j &amp;lt;= n; j += i) is_prime[j] = false; } } return p;}时间复杂度：O(nlognlogn)区间筛法对于求[a,b)区间内素数的问题可以采用区间筛法，即将埃氏筛法运用于[a,b)上。先分别做好[2,sqrt(b))和[a,b)的素数表，在从[2,sqrt(b))中筛得素数时，也将其倍数从[a,b)的表中划去，最后剩下的就是区间[a,b)内的素数了。typedef long long ll;bool is_prime[MAX_L];bool is_prime_small[MAX_SQRT_B];//对于区间[a,b)内的整数执行筛法。is_prime[i - a] ⇔ i是素数void segment_sieve(ll a, ll b){ for(int i= 0; (ll)i * i &amp;lt; b ; i++) is_prime_small[i] = true; for(int i = 2; i &amp;lt; b - a; i++) is_prime[i] = true; for(int i = 2; (ll) i * i&amp;lt; b; i++){ if(is_prime_small[i]){ for(int j = 2 * i; (ll)j * j &amp;lt; b; j += i) is_prime_small[j] = false; //筛[2，sqrt(b)) for(ll j = max(2LL, (a + i -1) / i) * i; j &amp;lt; b; j += i) is_prime[j - a] = false; //筛[a,b); } }}" }, { "title": "快速幂运算", "url": "/posts/%E5%BF%AB%E9%80%9F%E5%B9%82%E8%BF%90%E7%AE%97/", "categories": "算法", "tags": "幂运算", "date": "2020-10-22 16:55:00 +0800", "snippet": "普通的幂运算是将底数乘以底数指数次，需要O(n)的时间复杂度。通过将a的n次幂不断转换为a2的n/2次幂，可以将时间复杂度缩减至O(logn)typedef long long ll;int fastpow(int base, int exp){ int sum = 1; while(exp &amp;gt; 0){ if((exp &amp;amp; 1))//如果指数为奇数，将结果乘以底数 sum *= base; exp = exp &amp;gt;&amp;gt; 1;//指数除以2 base *= base;//底数平方 } return sum;" }, { "title": "Java类加载", "url": "/posts/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD/", "categories": "Java", "tags": "JVM", "date": "2020-10-21 16:10:00 +0800", "snippet": "类加载过程虚拟机只加载程序执行时所需要的类文件。假设程序从MyProject.class开始运行，以下时虚拟机执行的步骤： 虚拟机有一个用于加载类文件的机制，例如，从磁盘上读取文件或者请求Web上的文件；它使用该机制来加载MyProject类文件中的内容。 如果MyProject类拥有类型为另一个类的域，或者是拥有超类，那么这些文件也会被加载。（加载某个类所依赖的所有类的过程称为类的解析) 接着，虚拟机执行MyProject中的main方法（它是静态的，无需创建类的实例）。 如果main方法或者main调用的方法要用到更多的类，那么接下来就会加载这些类。然而，类加载机制并非只使用单个的类加载器。每个Java程序至少拥有3个类加载器： 引导类加载器 扩展类加载器 系统类加载器（有时也称为应用类加载器） 引导类加载器负责加载系统类（通常是从JAR文件rt.jar中进行加载）。它是虚拟机不可分割的一部分，而且通常是用C语言来实现的。引导类加载器没有对应的ClassLoader对象例如，该方法：String.class.getClassLoader()将返回null。扩展类加载器用于从 jre/lib/ext 目录加载“标准的扩展”。可以将JAR文件放入该目录，这样即使没有任何类路径，扩展类加载器也可以找到其中的各个类。 如果将JAR文件放入 jre/lib/ext 目录中，并且在它的类中有一个类需要掉哟个系统类或者扩展类，那么就会遇到麻烦，因为扩展类加载器并不使用类路径。在扩展目录来解决这种类文件的冲突之前要牢记这种情况。系统类加载器用于加载应用类。它在由CLASSPATH环境变量或者-classpath命令行选项设置的类路径中的目录里或者是JAR/ZIP文件里查找这些类在Oracle的Java语言实现中，扩展类加载器和系统类加载器都是用Java来实现的。它们都是URLClassLoader类的实例。注意：处理所有已经提到的位置，还可以从 jre/lib.endorsed 目录中加载类。这种机制只能用于将某个标准的Java类库替换为更新的版本（如那些支持XML和CORBA的类库）类加载器的层次结构类加载器有一种父/子关系。除了引导类加载器外，每个类加载器都有一个父类加载器。根据规定，类加载器会为它的父类加载器提供一个机会，以便加载任何给定的类，并且只有在其父类加载器加载失败时，它才会加载该给定类。（即双亲委派机制）例如，当要求系统类加载器加载一个系统类（比如，java.util.ArrayList）时，它首先要求扩展类架子啊其进行加载，该扩展类加载器则首先要求引导类加载器进行加载。引导类加载器会找到并加载rt.jar中的这个类，而无须其他类加载器做更多的搜索。某些程序具有插件架构，且其中代码的某些部分时作为可选的插件打包的。如果插件被打包为JAR文件，那就可以直接使用URLClassLoader类的实例去架子这些类。URL url = new URL(&quot;file://path/to/plugin.jar&quot;);ULRClassLoader pluginLoader = new URLClassLoader(new URL[] { url });Class&amp;lt;?&amp;gt; cl = pluginLoader.loadClass(&quot;mypackage.MyClass&quot;);因为在URLClassLoader构造器中没有指定父类加载器，因此pluginLoader的父亲就是系统类加载器。（层次结构如图）大多数情况下，我们无需操心类加载的层次结构。通常，类是由于其他类需要它而被加载的，而这个过程对于我们是透明的。但是，偶尔我们也需要干涉和指定类加载器。假设： 你的应用代码包含一个助手方法，它要调用Class.forName(class-NameString)。 这个方法是从一个插件类中被调用的。 而classNameString指定的是一个包含在这个插件的JAR类。由于助手方法的类是由系统类加载器加载的，这正是Class.forName所使用的类加载器。对它来说，在插件JAR中的类是不可见的。（这种现象被称为类加载器倒置）为了解决这个问题，助手方法需要使用恰当的类加载器，它可以要求类加载器作为其一个参数传递给它。或者，它可以要求将恰当的类加载器设置成为当前线程的上下文类加载器（这种策略在许多框架中都得到了应用） 每个线程都有一个对类加载器的引用，称为上下文类加载器。主线程的上下文类加载器是系统类加载器。当新线程创建时，它的上下文类加载器会被设置成为创建该线程的上下文类加载器。因此，如果你不做任何特殊的操作，那么所有的线程就都会将它们的上下文类加载器设置为系统类加载器。我们可以同下面的调用将上下文类加载器设置成为任何类加载器。Thread t = Thread.currentThread();t.setContextClassLoader(loader);然后助手方法可以获取这个上下文类加载器：Thread t = Thread.currentThread()lClassLoader loader = t.getContextClassLoader();Class cl = loader.loadClass(className);当上下文加载器设置为插件类加载器时，问题依旧存在。应用设计者必须作出决策：通常，当调用由不同的类加载器加载的插件类的方法时，进行上下文类加载器的设置是一种好的思路；或者让助手方法的调用者设置上下文类加载器。 Tips：如果编写了一个按名字来加载类的方法，那么让调用者在传递显示的类加载器和使用上下文类加载器之间进行选择就是一种好的做法。不要直接使用该方法所属的类的类加载器。" }, { "title": "Java中的static修饰符", "url": "/posts/Java%E4%B8%AD%E7%9A%84static%E4%BF%AE%E9%A5%B0%E7%AC%A6/", "categories": "Java", "tags": "Java基础", "date": "2020-10-20 16:35:00 +0800", "snippet": "用法static变量使用形式：类名.静态变量 （该类的实例也可调用，推荐使用类名调用）ClassName.variable在类加载的时候完成初始化，内存中只有一份（存储在静态区），该类的所有实例共享这一个变量。static方法使用形式：方法名前+static修饰可以使用类名直接调用，不必在对象中调用。静态方法中不可直接调用非静态方法。static内部类static 可以用于修饰内部类，经static修饰的内部类可以不新建内部类实例而直接通过外部类访问。static代码块static代码块可以放在类中的任意位置（除了方法内部），块中的代码会在类加载的时候按照代码块的顺序执行，并且只会执行一次。静态导包静态导包是简化书写使用的，使用了静态导包之后，就可以直接使用相关的静态变量，静态方法，不需要使用类名.变量和类名.方法来进行调用import static java.lang.Math.PI;public void method() { System.out.println(PI);}Tips 在C/C++中的static可以用来修饰局部变量，但是在Java中，static是不允许用来修饰局部变量的。 static关键字一般用在工具类里，工具类只需要一套，载入内存的时候对这些变量和方法进行初始化即可，不需要每次创建对象，然后调用相应的变量和方法，否则会浪费过多的内存资源。 如果static的变量和方法太多，而这些变量和方法是在JVM关闭的时候才进行清理的，在就会造成内存的浪费，而且可能会导致内存溢出。" }, { "title": "快速计算二进制数中1的个数", "url": "/posts/%E5%BF%AB%E9%80%9F%E8%AE%A1%E7%AE%97%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/", "categories": "算法", "tags": "二进制", "date": "2020-10-18 14:08:00 +0800", "snippet": "int count1inBin(int binary){ int count = 0; while(binary&amp;gt;0){ binary &amp;amp;= (binary-1); ++count; } return count;}核心在于binary &amp;amp;= (binary-1);假设binary=X1 X2 …… Xn-1 Xn，其中 Xi(1≤i≤n)为1或0不妨设Xi是最右边的1，那么binary就可以写成如下的形式 binary=X1 X2……Xi-1 Xi 0……0，其中(1≤i≤n)，Xi 后面有n-i个0 因为 Xi =1，所以binary=X1 X2 …… Xi-1 1 0……0，其中(1≤i≤n)，1后面有n-i个0 则binary-1=X1 X2 ……Xi-1 0 1……1，其中(1≤i≤n)，0后面有n-i个1 则binary &amp;amp; (binary-1)= X1 X1 …… Xi-1 0 0 ……0，其中(1≤i≤n)，Xi - 1后面有 n-i+1个0 因此，binary &amp;amp; (binarye-1)的效果把最右边的1变成0在上面的代码中，每把最右边的1变成0，则统计数加1，直到所有的1变成0为止。算法循环的次数和binary中的1的个数有关，循环的次数就是1的个数相较于移位的操作，减少了对数位上为0的数位的处理操作。" }, { "title": "动态规划概述", "url": "/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%A6%82%E8%BF%B0/", "categories": "算法", "tags": "动态规划", "date": "2020-10-18 13:55:00 +0800", "snippet": "动态规划（Dynamic Programming） 将一个问题拆成几个子问题，分别求解这些子问题，即可推断出大问题的解。如何判断一个问题能否使用DP解决呢？能将大问题拆成几个小问题，且满足无后效性、最优子结构性质。即是确定 DP状态最优子结构：将原有问题化分为一个个子问题，即为子结构。而对于每一个子问题，其最优值均由「更小规模的子问题的最优值」推导而来，即为最优子结构。因此「DP 状态」设置之前，需要将原有问题划分为一个个子问题，且需要确保子问题的最优值由「更小规模子问题的最优值」推出，此时子问题的最优值即为「DP 状态」的定义。无后效性：一旦f(n)确定，“我们如何凑出f(n)”就再也用不着了。要求出f(15)，只需要知道f(14),f(10),f(4)的值，而f(14),f(10),f(4)是如何算出来的，对之后的问题没有影响。“未来与过去无关”，这就是无后效性。（严格定义：如果给定某一阶段的状态，则在这一阶段以后过程的发展不受这阶段以前各段状态的影响。）步骤划分 刻画一个最优解的结构特征 递归地定义最优解的值 计算最优解的值，通常采用自底向上的方法 利用计算出的信息构造出一个最优解 步骤1～3是动态规划算法求解问题的基础。如果我们仅仅需要一个最优解的值，可以忽略步骤4.如果需要步骤4，有时就需要在步骤3的执行过程中维护一些额外信息，以便用来构造一个最优解。动态规划问题分类" }, { "title": "摩尔投票法", "url": "/posts/%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8%E6%B3%95/", "categories": "算法", "tags": "摩尔投票法", "date": "2020-10-18 12:36:00 +0800", "snippet": "Moore majority vote 算法摩尔投票法基于这样一个事实： 当一个数的重复次数超过数组长度的一半，每次将两个不相同的数删除，最终剩下的就是要找的数。我们采用一个虚拟数组（在实现中可以使用两个变量代替，一个代表当前数组内元素的个数，另一个储存当前的候选数）来储存候选的众数。当遇到相同的数的时候向虚拟数组中加入当前的候选数，遇到不同的数的时候从虚拟数组中删除一个候选数。如果虚拟数组大小为0，向虚拟数组中加入当前位置的数作为候选数。遍历完成后数组中剩余的元素就是众数。因为众数大于数组的一半，哪怕最极端的其它数全都相同，众数也能在数组中剩余不少于2m-n（其中m为众数的数量，n为数组大小）。int majorityElement(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int res=0,cnt=0; for(int i=0;i&amp;lt;nums.size();i++){ if(cnt==0) { res=nums[i]; cnt++; } else{ res==nums[i]?cnt++:cnt--; } } return res; }扩展求在长度为n的数组中出现次数超过n/3的数明显的，长度超过n/3的数最多只有2个。按照摩尔投票法的思路，我们可以设置两个虚拟数组，最终两个数组中的数就是满足条件的数（如果题目没有说明一定存在，则可以进行一轮遍历验证） 如下方代码所示逻辑，相当于平均每次访问了3个数字，因为所求数字重复次数超过了n/3，所以按平均的情况每次访问时都会存在有所求数字保留在虚拟数组中，即：一定会占据虚拟数组一个栏位。void getSuitableNumber(vector&amp;lt;int&amp;gt; arr) { int x, y, cx = 0, cy = 0;//两个虚拟数组 x = 300000;//任意一个不存在于数组中的值作为初始值 y = 400000; for (int i = 0; i &amp;lt; arr.size(); ++i) { if (x == arr[i]) ++cx; else if (y == arr[i]) ++cy; else if (cx == 0) x = arr[i], cx = 1; else if (cy == 0) y = arr[i], cy = 1;//这两个判断不能提前，因为可能把x,y赋为同一个值 else --cx, --cy; } cx = 0, cy = 0; for (int i = 0; i &amp;lt; arr.size(); ++i) {//锁定候选目标，遍历数组，计数，做验证 if (arr[i] == x) ++cx; else if (arr[i] == y) ++cy; } if (cx &amp;gt; arr.size() / 3) { printf(&quot;超过1/3的数有：%d\\n&quot;, x); } if (cy &amp;gt; arr.size() / 3) { printf(&quot;超过1/3的数有：%d\\n&quot;, y); }}长度为n的数组中出现次数超过n/k的数按照之前的逻辑，只需设置k-1个虚拟数组，最后留下的数字即可能是满足条件的数。" }, { "title": "StringBuilder和StringBuffer", "url": "/posts/StringBuilder%E5%92%8CStringBuffer/", "categories": "Java", "tags": "StringBuilder和StringBuffer", "date": "2020-10-17 14:47:00 +0800", "snippet": "层次结构StringBufferStringBuilderStringBufferStringBuffer 是一个线程安全类，它对append（）方法做了synchronized处理。在AbstractStringBuilder中：public AbstractStringBuilder append(String str){ if(str == null) return appendNull(); int len = str.length(); ensureCapacityInternal(count + len); str.getChars(0, len, value. count); count += len; return this;}StringBuffer和StringBuilder均为AbstractStringBuilder类的实现，我们可以看到方法中执行两个步骤： 对追加后的字符串进行长度预判断（此时未将str添加到原对象中），如果现存的value[]长度不满足追加后的长度，则以追加后的字符串长度进行newCapacity() 调用String类中的getChars()方法，将字符真正添加到原字符串对象中去。明显，AbstractStringBuilder.append()方法的操作不满足原子性，所以在多线程环境下可能会导致数组越界异常、结果数据不正确等非与其的问题。StringBuffer采用synchronized进行同步，所以可以保证在多线程环境下的线程安全。构造函数StringBuffer() //value内容为空，并设置容量为16个字节；StringBuffer(CharSequece seq) //使用seq初始化，容量在此基础上加16；StringBuffer(int capacity) //设置特定容量；StringBuffer(String str) //使用str初始化，容量str大小的基础上加16；StringBuilderStringBuilder的原理和StringBuffer一样，不同之处在于StringBuilder不需要考虑线程安全。构造函数StringBuilder() //value内容为空，并设置容量为16个字节；StringBuilder(CharSequece seq) //使用seq初始化，容量在此基础上加16；StringBuilder(int capacity) //设置特定容量；StringBuilder(String str) //使用str初始化，容量str大小的基础上加16；常用方法两者均有以下方法：public StringBuffer append(String s)//将指定的字符串追加到此字符序列。public StringBuffer reverse() //将此字符序列用其反转形式取代。public delete(int start, int end)//移除此序列的子字符串中的字符.public insert(int offset, int i)//将 int 参数的字符串表示形式插入此序列中。replace(int start, int end, String str)//使用给定 String 中的字符替换此序列的子字符串中的字符。String toString()//返回此序列中数据的字符串表示形式。String substring(int start, int end)//返回一个新的 String，它包含此序列当前所包含的字符子序列。String substring(int start)//返回一个新的 String，它包含此字符序列当前所包含的字符子序列。CharSequence subSequence(int start, int end)//返回一个新的字符序列，该字符序列是此序列的子序列。void setLength(int newLength)//设置字符序列的长度。int capacity()//返回当前容量。char charAt(int index)//返回此序列中指定索引处的 char 值。void ensureCapacity(int minimumCapacity)//确保容量至少等于指定的最小值。void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)//将字符从此序列复制到目标字符数组 dst。int indexOf(String str)//返回第一次出现的指定子字符串在该字符串中的索引。int indexOf(String str, int fromIndex)//从指定的索引处开始，返回第一次出现的指定子字符串在该字符串中的索引。int lastIndexOf(String str)//返回最右边出现的指定子字符串在此字符串中的索引。int lastIndexOf(String str, int fromIndex)//返回 String 对象中子字符串最后出现的位置。int length()// 返回长度（字符数）。void setCharAt(int index, char ch)//将给定索引处的字符设置为 ch。" }, { "title": "排序算法", "url": "/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/", "categories": "算法", "tags": "排序算法", "date": "2020-10-15 00:00:00 +0800", "snippet": "常用排序算法比较 排序方法 平均时间复杂度 最坏时间复杂度 最好时间复杂度 空间复杂度 稳定性 复杂性 插入排序 O(n2) O(n2) O(n) O(1) 稳定 简单 希尔排序 O(n1.3)     O(1) 不稳定 较复杂 冒泡排序 O(n2) O(n2) O(n) O(1) 稳定 简单 快速排序 O(nlog2n) O(n2) O(nlog2n) O(log2n) 不稳定 较复杂 选择排序 O(n2) O(n2) O(n2) O(1) 不稳定 简单 堆排序 O(nlog2n) O(nlog2n) O(nlog2n) O(1) 不稳定 较复杂 归并排序 O(nlog2n) O(nlog2n) O(nlog2n) O(n) 稳定 较复杂 基数排序 O(d(n+r)) O(d(n+r)) O(d(n+r)) O(r) 稳定 较复杂 堆排序堆排序（Heapsort）是利用堆这种数据结构所设计的一种排序算法基本步骤： 首先将数组构建成一个小顶堆（或大顶堆） 从堆顶nums[0]取出最小值（或最大值）放到数组后端nums[n]处，然后将nums[0]重新调整为小顶堆（或大顶堆）,再将nums[0]与nums[n-1]…. 重复步骤2，直到整个数组都有序（堆的大小为1时）。 时间复杂度O(nlog2n)//调整函数void mHeap(vector&amp;lt;int&amp;gt;&amp;amp; nums,int start, int end) { int l, r; while (start*2+1 &amp;lt;= end) { l = start * 2 + 1; r = start * 2 + 2; if (r &amp;lt;= end &amp;amp;&amp;amp; nums[l] &amp;lt; nums[r])//将标志位设置为左右子节点中最大（小）的 l = r; if (nums[start] &amp;gt; nums[l]) {//当节点大于左右子节点的值时停止 break; } swap(nums[start], nums[l]); start = l; }}void HeapSort(vector&amp;lt;int&amp;gt;&amp;amp; nums, int size) { //将数组构建成为一个大顶堆 for (int i = size / 2 - 1; i &amp;gt;= 0; --i) {//从倒数第二层开始，到根节点为止 mHeap(nums, i, size - 1); } //不断将堆顶元素移至堆底，并将堆的大小-1，当堆的大小为1时，排序完成 for (int i = size - 1; i &amp;gt; 0; --i) { swap(nums[i], nums[0]); mHeap(nums, 0, i - 1); }}快速排序快速排序是分而治之思想在算法上的典型应用，快速排序使用分治法策略把一个串行（list）分为两个子串行（sub-list）。基本步骤： 将第i个元素作为基准（pivot） 重新排序数列，所有元素比基准值小的放在基准前面，所有比基准值大的放在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序； 时间复杂度最好情况O(nlog2n)：Partition 每次恰好能均分序列，其递归树的深度就为.log2n.+1（.x.表示不大于x的最大整数），即仅需递归log2n次最坏情况O(n2):每次划分只能将序列分为一个元素与其他元素两部分，这时的快速排序退化为冒泡排序 (如待排序数组已经有序)void quicksort(vector&amp;lt;int&amp;gt;&amp;amp; nums,int left,int right) { //Partition Begin int pivot; int i = left, j = right; pivot = nums[i]; while (i != j) { while (i &amp;lt; j &amp;amp;&amp;amp; nums[j] &amp;gt;= pivot)//此处须使用&amp;gt;=（如果使用&amp;gt;可能在两侧都等于pivot时产生死循环） --j; if (i &amp;lt; j) { nums[i] = nums[j]; } while (i &amp;lt; j &amp;amp;&amp;amp; nums[i] &amp;lt;= pivot) ++i; if (i &amp;lt; j) { nums[j] = nums[i]; } } nums[i] = pivot; //Partition End if (left &amp;lt; i-1)//递归在左右子分区调用 quicksort(nums, left, i-1); if (i+1 &amp;lt; right) quicksort(nums, i+1, right);}归并排序归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序的实现分为两种： 自上而下的递归 （所有递归的方法都可以用迭代重写，所以就有了第 2 种方法） 自下而上的迭代算法步骤： 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列 设定两个指针，最初位置分别为两个已经排序序列的起始位置 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置 重复步骤3，直到某一指针达到序列尾 将另一序列剩下的所有元素直接复制到合并序列尾 时间复杂度O(nlog2n)由上至下的递归示例：通过”从上往下的归并排序”来对数组{80,30,60,40,20,10,50,70}进行排序时： 将数组{80,30,60,40,20,10,50,70}看作由两个有序的子数组{80,30,60,40}和{20,10,50,70}组成。对两个有序子树组进行排序即可。 将子数组{80,30,60,40}看作由两个有序的子数组{80,30}和{60,40}组成。 将子数组{20,10,50,70}看作由两个有序的子数组{20,10}和{50,70}组成。 将子数组{80,30}看作由两个有序的子数组{80}和{30}组成。 将子数组{60,40}看作由两个有序的子数组{60}和{40}组成。 将子数组{20,10}看作由两个有序的子数组{20}和{10}组成。 将子数组{50,70}看作由两个有序的子数组{50}和{70}组成。void mergeSort(vector&amp;lt;int&amp;gt;&amp;amp; nums, int start, int end) { int mid; if (nums.empty() || start &amp;gt;= end)//当数列为空或者切分为单个元素的数列时，终止切分 return; mid = (start + end) / 2; mergeSort(nums, start, mid);//递归切分 mergeSort(nums, mid + 1, end);z merge(nums, start, mid, end);}void merge(vector&amp;lt;int&amp;gt;&amp;amp; nums, int start, int mid, int end) { vector&amp;lt;int&amp;gt; temp; int i = start, j = mid + 1; while (i &amp;lt;= mid &amp;amp;&amp;amp; j &amp;lt;= end) {//依次将两个有序数列中较小的数加入到临时向量中 if (nums[i] &amp;lt; nums[j]) temp.push_back(nums[i++]); else temp.push_back(nums[j++]); } while (i &amp;lt;= mid) temp.push_back(nums[i++]); while (j &amp;lt;= end) temp.push_back(nums[j++]); for (int p = 0; p &amp;lt; temp.size(); ++p) {//将排序后的数列从临时向量中转移回去 nums[start + p] = temp[p]; }}由下至上的迭代示例：通过”从下往上的归并排序”来对数组{80,30,60,40,20,10,50,70}进行排序时： 将数组{80,30,60,40,20,10,50,70}看作由8个有序的子数组{80},{30},{60},{40},{20},{10},{50}和{70}组成。 将这8个有序的子数列两两合并。得到4个有序的子树列{30,80},{40,60},{10,20}和{50,70}。 将这4个有序的子数列两两合并。得到2个有序的子树列{30,40,60,80}和{10,20,50,70}。 将这2个有序的子数列两两合并。得到1个有序的子树列{10,20,30,40,50,60,70,80}。void merge(vector&amp;lt;int&amp;gt;&amp;amp; nums, int start, int mid, int end) { vector&amp;lt;int&amp;gt; temp; int i = start, j = mid + 1; while (i &amp;lt;= mid &amp;amp;&amp;amp; j &amp;lt;= end) {//依次将两个有序数列中较小的数加入到临时向量中 if (nums[i] &amp;lt; nums[j]) temp.push_back(nums[i++]); else temp.push_back(nums[j++]); } while (i &amp;lt;= mid) temp.push_back(nums[i++]); while (j &amp;lt;= end) temp.push_back(nums[j++]); for (int p = 0; p &amp;lt; temp.size(); ++p) {//将排序后的数列从临时向量中转移回去 nums[start + p] = temp[p]; }}/*对数组a做若干次合并：数组a的总长度为len，将它分为若干个长度为gap的子数组； * 将&quot;每2个相邻的子数组&quot; 进行合并排序。 * * 参数说明： * a -- 待排序的数组 * len -- 数组的长度 * gap -- 子数组的长度 */void mergeGroups(int* a, int len, int gap){ int i; // 将&quot;每2个相邻的子数组&quot; 进行合并排序。 for(i = 0; i+2*gap-1 &amp;lt; len; i+=(2*gap)) { merge(a, i, i+gap-1, i+2*gap-1); } // 若 i+gap-1 &amp;lt; len-1，则剩余一个子数组没有配对。 // 将该子数组合并到已排序的数组中。 if ( i+gap-1 &amp;lt; len-1) { merge(a, i, i + gap - 1, len - 1); }}/* * 归并排序(从下往上) * * 参数说明： * a -- 待排序的数组 * len -- 数组的长度 */void mergeSortDown2Up(int* a, int len){ int n; if (a==NULL || len&amp;lt;=0) return ; for(n = 1; n &amp;lt; len; n*=2) mergeGroups(a, len, n);}冒泡排序冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢”浮”到数列的顶端。算法步骤： 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 时间复杂度最好情况O(n)：数组是正序时最坏情况O(n2):数组是反序时void bubble_sort(vector&amp;lt;int&amp;gt;&amp;amp; n){ for(int i = 1; i &amp;lt; n.size() - 1 ; ++i) for(int j = 0; j &amp;lt; n.size() - i; ++j) if(n[j] &amp;gt; n[j + 1]) swap(n[j], n[j + 1]);}选择排序选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度算法步骤： 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 重复第二步，直到所有元素均排序完毕。时间复杂度O(n2)//选择排序void select_sort(int arr[], int n){ int i; //有序区的末尾位置 int j; //无序区的起始位置 int min; //无序区中的最小元素位置 for(i = 0; i &amp;lt; n; ++i){ min = i; //找出&quot;arr[i+1] ... arr[n]&quot;之间的最小元素的位置，并赋值给min for(j = i+1; j &amp;lt; n; ++j){ if(arr[j] &amp;lt; a[min]) min = j; } //交换arr[i]和arr[min]，交换之后保证了arr[0] ... arr[i]之间的元素是有序的 if(min != i){ swap(arr[i], arr[min]); } }}插入排序插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。算法步骤： 将待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）时间复杂度最坏情况O(n2):插入第2个元素时要考察前1个元素，插入第3个元素时，要考虑前2个元素，……，插入第N个元素，要考虑前 N - 1 个元素。因此，最坏情况下的比较次数是 1 + 2 + 3 + … + (N - 1)，等差数列求和，结果为 N2 / 2最好情况O(n):数组已经是有序的，每插入一个元素，只需要考查前一个元素，因此最好情况下，插入排序的时间复杂度为O(n)void InsertSort(int array[], int len) { for (int i = 1; i &amp;lt; len; i++) { int j = i-1; int temp = array[i]; while (j &amp;gt;= 0 &amp;amp;&amp;amp; array[j] &amp;gt; temp) {//此处实现为从右至左，即i-1到0） array[j + 1] = array[j]; j--; } if (j != i - 1) array[j + 1] = temp; }}希尔排序希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是不稳定的。希尔排序是基于插入排序的以下两点性质而提出改进方法的： 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率； 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；基本思想：希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。算法步骤： 选择一个增量序列 g1，g2，……gi … gj……，gk，其中 gi &amp;gt; gj, gk = 1；按增量序列个数 k，对序列进行 k 趟排序 每趟排序，根据对应的增量 gi，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。当增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 时间复杂度最好情况O(nsub&amp;gt;1.3&amp;lt;/sub&amp;gt;)：采用Hibbard增量序列时下方代码采用shell增量序列，时间复杂度会高于Hibbard序列void shell_sort(vector&amp;lt;int&amp;gt;&amp;amp; n) { int gap = n.size() / 2;//构建shell增量序列 while (gap &amp;gt; 0) { int i, j; //具体实现时采用跨组处理的方式，即先处理每组i+gap再处理i+gap+gap以此类推... for (i = gap; i &amp;lt; n.size(); i++) { j = i - gap; int temp = n[i]; while (j &amp;gt;= 0 &amp;amp;&amp;amp; n[j] &amp;gt; temp) { n[j + gap] = n[j]; j -= gap; } n[j + gap] = temp; } gap = gap &amp;gt;&amp;gt; 1; }}计数排序计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。计数排序不是比较排序，排序的速度快于任何比较排序算法时间复杂度O(n+k)n为数组的长度，k为数组中最大整数的值算法步骤： 找出待排序的数组中最大和最小的元素k 统计数组中每个值为i的元素出现的次数，存入数组C（大小为k+1）的第i项 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加） 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1vector&amp;lt;int&amp;gt; countingSort(vector&amp;lt;int&amp;gt; arr){ int k = getK(arr); int pos = 0; vector&amp;lt;int&amp;gt; bucket(k+1,0); for(int i = 0; i &amp;lt; arr.size(); i++){ bucket[arr[i]]++; } for(int i = 0; i &amp;lt; bucket.size(); i++){ while(bucket[i] &amp;gt; 0){ arr[pos++] = i; bucket[i]--; } } return arr;}int getK(vector&amp;lt;int&amp;gt; arr){ int largest = arr[0]; for(int i = 1; i &amp;lt; arr.size(); i++){ if(arr[i] &amp;gt; largest) largest = arr[i]; } return largest;}桶排序桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点： 在额外空间充足的情况下，尽量增大桶的数量 使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中 同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。时间复杂度：O(n + f(n/m))n为数组的长度，m为桶的数量,f()为对桶中元素进行排序的算法的时间复杂度公式。当n==m时，退化为计数排序空间复杂度为： max(n, m).const int BUCKET_NUM = 10;//定义桶的大小struct ListNode{//定义链表节点 explicit ListNode(int i=0):mData(i),mNext(NULL){} ListNode* mNext; int mData;};ListNode* insert(ListNode* head,int val){//向链表按照插入排序方式插入新节点 ListNode dummyNode; ListNode *newNode = new ListNode(val); ListNode *pre,*curr; dummyNode.mNext = head; pre = &amp;amp;dummyNode; curr = head; while(NULL!=curr &amp;amp;&amp;amp; curr-&amp;gt;mData&amp;lt;=val){ pre = curr; curr = curr-&amp;gt;mNext; } newNode-&amp;gt;mNext = curr; pre-&amp;gt;mNext = newNode; return dummyNode.mNext;}ListNode* Merge(ListNode *head1,ListNode *head2){//归并两个链表 ListNode dummyNode; ListNode *dummy = &amp;amp;dummyNode; while(NULL!=head1 &amp;amp;&amp;amp; NULL!=head2){ if(head1-&amp;gt;mData &amp;lt;= head2-&amp;gt;mData){ dummy-&amp;gt;mNext = head1; head1 = head1-&amp;gt;mNext; }else{ dummy-&amp;gt;mNext = head2; head2 = head2-&amp;gt;mNext; } dummy = dummy-&amp;gt;mNext; } if(NULL!=head1) dummy-&amp;gt;mNext = head1; if(NULL!=head2) dummy-&amp;gt;mNext = head2; return dummyNode.mNext;}void BucketSort(int n,int arr[]){ vector&amp;lt;ListNode*&amp;gt; buckets(BUCKET_NUM,(ListNode*)(0));//创建桶 for(int i=0;i&amp;lt;n;++i){ int index = arr[i]/BUCKET_NUM;//从数组映射到桶 ListNode *head = buckets.at(index); buckets.at(index) = insert(head,arr[i]); } ListNode *head = buckets.at(0); for(int i=1;i&amp;lt;BUCKET_NUM;++i){//依次合并所有桶 head = Merge(head,buckets.at(i)); } for(int i=0;i&amp;lt;n;++i){//将链表中的数据覆写到数组中 arr[i] = head-&amp;gt;mData; head = head-&amp;gt;mNext; }}基数排序基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。这样从最低位排序一直到最高位排序完成以后,数列就变成一个有序序列. 由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。时间复杂度O(d*(n+b))：d为数组中数字位数的最大值，其中b是数字的进制数int maxbit(int data[], int n) //辅助函数，求数据的最大位数{ int maxData = data[0]; ///&amp;lt; 最大数 /// 先求出最大数，再求其位数，这样有原先依次每个数判断其位数，稍微优化点。 for (int i = 1; i &amp;lt; n; ++i) { if (maxData &amp;lt; data[i]) maxData = data[i]; } int d = 1;//最大数的位数 int p = 10; while (maxData &amp;gt;= p) { //p *= 10; 会有溢出的风险，所以采用降低maxData的数位 maxData /= 10; ++d; } return d;}void radixsort(int data[], int n) //基数排序{ int d = maxbit(data, n); int *tmp = new int[n]; int *count = new int[10]; //计数器 int i, j, k; int radix = 1; for(i = 1; i &amp;lt;= d; i++) //进行d次排序 { for(j = 0; j &amp;lt; 10; j++) count[j] = 0; //每次分配前清空计数器 for(j = 0; j &amp;lt; n; j++) { k = (data[j] / radix) % 10; //统计每个桶中的记录数 count[k]++; } for(j = 1; j &amp;lt; 10; j++) count[j] = count[j - 1] + count[j]; //将tmp中的位置依次分配给每个桶 for(j = n - 1; j &amp;gt;= 0; j--) //将所有桶中记录依次收集到tmp中 { k = (data[j] / radix) % 10; tmp[count[k] - 1] = data[j]; count[k]--; } for(j = 0; j &amp;lt; n; j++) //将临时数组的内容复制到data中 data[j] = tmp[j]; radix = radix * 10; } delete []tmp; delete []count;}" } ]
